
- データを保持するだけのクラス(=データクラス)をつくると計算ロジックは別のクラスに実装されることが多い
  - データと計算ロジックが離れた場所に実装されていると計算ロジックが複数実装されていても認知が難しい
  - 関連するデータとロジックが分散している状態を「低凝集」という

- 初期化処理が必要であったり、利用者側が使い方を知らないといけない未初期化状態が発生しうるクラスを作らない

- クラスに関係するデータとロジックをまとめる
  - コンストラクタで不正な値が入らないようにしておく
  - 高凝集なクラス

- クラス単体で正常動作するように設計する
  - 構成部品であるクラス一つ一つが品質的に完結するようにする 
  
- 正しく操作できるメソッドのみを外部に提供する(カプセル化)

- クラス設計はインスタンス変数を不正状態に陥らせないための仕組みづくり

- 値オブジェクト+完全コンストラクタで設計すると制約や意図を型として表現可能になる

- データとデータを操作するロジックを一箇所にまとめて高凝集にし、必要な操作だけを外に公開するようカプセル化する

- 副作用とは関数が引数を受け取り戻り値を返す以外に、外部の状態を変更すること
  - インスタンス変数、グローバル変数、引数の変更 
  - ファイルの読み書き

- 引数で状態を受け取り、状態変更せず値を返すだけの関数が理想

- 凝集度はモジュール内におけるデータとロジックの関係性の強さを表す指標

- static メソッドはインスタンス変数を使えないので、データとデータを操作するロジックが乖離する
  - インスタンス変数を使わず引数で受け取った値を使って計算するだけのメソッドは static をつけても動作する
  - 凝集度に影響のないログ出力メソッドは static メソッドで設計して良い

- コンストラクタを公開すると様座生用途で使われ、初期化ロジックが分散する
  - コンストラクタを private にして目的別のファクトリメソッドを作る

- common,util といった共通を匂わせる命名は関連のないロジックが雑多に置かれ低凝集な構造を作りやすい
  - 再利用性は高凝集な設計にすることで高まる

- 出力として用いる引数を「出力引数」と呼ぶ
  - 引数は入力値として渡す
  - 出力値として扱うと、入出力どちらで使われているかメソッドの中身を読んで確認する必要がある

- メソッドに渡す引数が増えると処理させたい内容が膨らんでいる状態が多い
  - データを引数として扱うのではなく、そのデータをインスタンス変数として持つクラスに変更できるかも

- メソッドチェインは階層構造の奥の要素にアクセスするため低凝集に陥る
  - 利用するオブジェクトの内部を知るべきではないという「デルメルの法則」に違反する

- interface を用いて処理を切り替える設計を「ストラテジパターン」と呼ぶ

- 条件を部品化し、それらを組み替えることでカスタマイズを可能にするのが「ポリシーパターン」

- メソッドの機能を切り替えるフラグ引数が使われていると、メソッド内部のロジックを見ないといけないため可読性が低下する
  - 機能を切り替えるための引数は、セレクタ引数と呼ばれる
  - セレクタ引数で機能を切り替えているのでメソッドが多目的である

- コレクションに関する処理は複数の場所に実装されがちなので、ファーストクラスコレクションを作る
  - コレクションに関連するロジックをカプセル化する設計パターンで低凝集を解決する

- SRP(Single Responsibility Principle)に則り、個別に責任を負うクラスを作る
  - 関心事がそれぞれに分離、独立している状態を「疎結合」と呼ぶ
  - 重複コードや同じようなロジックはなんでも束ねればいいわけではなく、責務を考える
  - DRYにすべきはそれぞれの概念の単位であるため、責務が異なるものをひとまとめにしない

- ビジネスの理解が進んでくると、ある概念が実は複数の異なる概念だったという状況が頻発する  

- 継承関係にあるクラス同士では、サブクラスはスーパクラスの構造に強く依存する
  - スーパクラスの構造を気にしないと、スーパクラスの変更によりサブクラスはバグ化する
  - スーパークラスはサブクラスのことは知らず変更できる
  - スーパークラスが共通ロジックの置き場所として利用されがちで、無理に共通化しようとして密結合になる

- 継承よりも委譲する、コンポジション構造にする
  - お互いのクラス構造を知らなくても良い、影響が伝播しにくいクラス構造を目指す

- 密結合を避けるために、アクセス修飾子で適切に制御する
  - アクセス修飾子無しの package private は同じパッケージからアクセス可能
  - パッケージは関連づくクラス同士を凝集するよう設計する
  - 継承クラスからアクセスしたい場合は protected
  - 外部からアクセスできるように公開したい場合のみ public を宣言する

- 高凝集を意図して関係していそうなロジックを1箇所にまとめた結果、密結合になることも
  - それぞれの概念を分離し、疎結合かつ高凝集を目指す

- 表示以外の責務がフロントに実装されている構造を「スマートUI」と呼ぶ
  - 新デザインに差し替えるとバグがおきる

- 巨大なデータクラスは多くのインスタンス変数をもつ
  - ex.) 発注から配送まで参照されるECサイトの Order クラス 
  - ユースケースごとに必要なデータ以外にも触れる構造になる
  - グローバル変数の性質を持つようになる

- メソッド内に一連の処理手順が長く書き連ねられる構造を「トランザクションスクリプトパターン」と呼ぶ
  - データクラスとデータを処理するクラスと分かれている場合に見られる実装

- ロジック内に直接書き込まれる意味不明な数値を「マジックナンバー」と呼ぶ

- 何かを持っていない状態や未設定の状態も立派な状態であり null でそれを表現しない
  - null は状態すら存在していない
  - null を取り扱わない(返さない、渡さない)設計にする

- プログラミングにおける名前の役割は、可読性を高めることだけでなく関心の分離を意識するためのもの
  - 疎結合高凝集を実現するためにビジネス目的に沿った名前を付与する
  - 特定の目的の達成に特化した範囲の狭い名前をクラスに付与する
  - 大雑把な名前はあらゆるロジックを引きつけてしまう
  - 存在ベースではなく目的ベースで命名する
    - ex.) 住所より、配送元、配送先、勤務地など

- Info,Data と命名されたクラスはロジックを付与しないデータクラスだと読み手に印象付けてしまう

- Manager と名付けられたクラスは「管理」の意味が曖昧で、さまざまな責務が追加されがち

- Controller は受け取ったリクエストパラメータを他のクラスに渡す責務に留める

- boolean型を返すメソッドは責務内に書かれているか満たすために「class is 状態」と読み替える

- カプセル化とはデータとそのデータの操作ロジックを1つのクラスにまとめ、必要な手続きのみを外部に公開すること
  - getter/setter を用意することではない

- システムの構造を説明するために単純な箱で図式化したものをモデルという

- モデルは特定の目的を達成するための最低限考慮が必要な要素を備えたもの
  - 注文と配送では達成目的が違うため、それぞれで扱う商品のモデルを別にする
    - GitHubのユーザ設定画面は目的ごとに設定項目が分かれている

- モデリングには対象の観察と要素抽出が必要
  - 現実世界での物理的な存在と情報システム上のモデルが 1:1 になるとは限らない
  - モデルを単なるモノとして解釈しているとモデリングがうまくいかない

- 機能追加とリファクタリングを同時に行わない(2つの帽子を切り替える)
